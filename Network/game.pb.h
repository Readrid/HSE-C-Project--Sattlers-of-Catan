// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: game.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_game_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_game_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_game_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_game_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[11]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_game_2eproto;
namespace game {
class Bool;
class BoolDefaultTypeInternal;
extern BoolDefaultTypeInternal _Bool_default_instance_;
class Build;
class BuildDefaultTypeInternal;
extern BuildDefaultTypeInternal _Build_default_instance_;
class Card;
class CardDefaultTypeInternal;
extern CardDefaultTypeInternal _Card_default_instance_;
class Dice;
class DiceDefaultTypeInternal;
extern DiceDefaultTypeInternal _Dice_default_instance_;
class Event;
class EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class GameId;
class GameIdDefaultTypeInternal;
extern GameIdDefaultTypeInternal _GameId_default_instance_;
class Market;
class MarketDefaultTypeInternal;
extern MarketDefaultTypeInternal _Market_default_instance_;
class NumberOfPlayers;
class NumberOfPlayersDefaultTypeInternal;
extern NumberOfPlayersDefaultTypeInternal _NumberOfPlayers_default_instance_;
class OrderInfo;
class OrderInfoDefaultTypeInternal;
extern OrderInfoDefaultTypeInternal _OrderInfo_default_instance_;
class Player;
class PlayerDefaultTypeInternal;
extern PlayerDefaultTypeInternal _Player_default_instance_;
class Void;
class VoidDefaultTypeInternal;
extern VoidDefaultTypeInternal _Void_default_instance_;
}  // namespace game
PROTOBUF_NAMESPACE_OPEN
template<> ::game::Bool* Arena::CreateMaybeMessage<::game::Bool>(Arena*);
template<> ::game::Build* Arena::CreateMaybeMessage<::game::Build>(Arena*);
template<> ::game::Card* Arena::CreateMaybeMessage<::game::Card>(Arena*);
template<> ::game::Dice* Arena::CreateMaybeMessage<::game::Dice>(Arena*);
template<> ::game::Event* Arena::CreateMaybeMessage<::game::Event>(Arena*);
template<> ::game::GameId* Arena::CreateMaybeMessage<::game::GameId>(Arena*);
template<> ::game::Market* Arena::CreateMaybeMessage<::game::Market>(Arena*);
template<> ::game::NumberOfPlayers* Arena::CreateMaybeMessage<::game::NumberOfPlayers>(Arena*);
template<> ::game::OrderInfo* Arena::CreateMaybeMessage<::game::OrderInfo>(Arena*);
template<> ::game::Player* Arena::CreateMaybeMessage<::game::Player>(Arena*);
template<> ::game::Void* Arena::CreateMaybeMessage<::game::Void>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace game {

enum EventType : int {
  CARD = 0,
  DICE = 1,
  MARKET = 2,
  BUILD = 3,
  ENDTURN = 4,
  NEXTPHASE = 5,
  ENDGAME = 6,
  EventType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EventType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool EventType_IsValid(int value);
constexpr EventType EventType_MIN = CARD;
constexpr EventType EventType_MAX = ENDGAME;
constexpr int EventType_ARRAYSIZE = EventType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EventType_descriptor();
template<typename T>
inline const std::string& EventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EventType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EventType_descriptor(), enum_t_value);
}
inline bool EventType_Parse(
    const std::string& name, EventType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EventType>(
    EventType_descriptor(), name, value);
}
// ===================================================================

class Void :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.Void) */ {
 public:
  Void();
  virtual ~Void();

  Void(const Void& from);
  Void(Void&& from) noexcept
    : Void() {
    *this = ::std::move(from);
  }

  inline Void& operator=(const Void& from) {
    CopyFrom(from);
    return *this;
  }
  inline Void& operator=(Void&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Void& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Void* internal_default_instance() {
    return reinterpret_cast<const Void*>(
               &_Void_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Void& a, Void& b) {
    a.Swap(&b);
  }
  inline void Swap(Void* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Void* New() const final {
    return CreateMaybeMessage<Void>(nullptr);
  }

  Void* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Void>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Void& from);
  void MergeFrom(const Void& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Void* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.Void";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_game_2eproto);
    return ::descriptor_table_game_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:game.Void)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class Bool :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.Bool) */ {
 public:
  Bool();
  virtual ~Bool();

  Bool(const Bool& from);
  Bool(Bool&& from) noexcept
    : Bool() {
    *this = ::std::move(from);
  }

  inline Bool& operator=(const Bool& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bool& operator=(Bool&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Bool& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Bool* internal_default_instance() {
    return reinterpret_cast<const Bool*>(
               &_Bool_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Bool& a, Bool& b) {
    a.Swap(&b);
  }
  inline void Swap(Bool* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Bool* New() const final {
    return CreateMaybeMessage<Bool>(nullptr);
  }

  Bool* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Bool>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Bool& from);
  void MergeFrom(const Bool& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Bool* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.Bool";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_game_2eproto);
    return ::descriptor_table_game_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHasEventFieldNumber = 1,
  };
  // bool hasEvent = 1;
  void clear_hasevent();
  bool hasevent() const;
  void set_hasevent(bool value);
  private:
  bool _internal_hasevent() const;
  void _internal_set_hasevent(bool value);
  public:

  // @@protoc_insertion_point(class_scope:game.Bool)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  bool hasevent_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class NumberOfPlayers :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.NumberOfPlayers) */ {
 public:
  NumberOfPlayers();
  virtual ~NumberOfPlayers();

  NumberOfPlayers(const NumberOfPlayers& from);
  NumberOfPlayers(NumberOfPlayers&& from) noexcept
    : NumberOfPlayers() {
    *this = ::std::move(from);
  }

  inline NumberOfPlayers& operator=(const NumberOfPlayers& from) {
    CopyFrom(from);
    return *this;
  }
  inline NumberOfPlayers& operator=(NumberOfPlayers&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NumberOfPlayers& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NumberOfPlayers* internal_default_instance() {
    return reinterpret_cast<const NumberOfPlayers*>(
               &_NumberOfPlayers_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(NumberOfPlayers& a, NumberOfPlayers& b) {
    a.Swap(&b);
  }
  inline void Swap(NumberOfPlayers* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NumberOfPlayers* New() const final {
    return CreateMaybeMessage<NumberOfPlayers>(nullptr);
  }

  NumberOfPlayers* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NumberOfPlayers>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NumberOfPlayers& from);
  void MergeFrom(const NumberOfPlayers& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NumberOfPlayers* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.NumberOfPlayers";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_game_2eproto);
    return ::descriptor_table_game_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumberOfPlayersFieldNumber = 1,
  };
  // int32 numberOfPlayers = 1;
  void clear_numberofplayers();
  ::PROTOBUF_NAMESPACE_ID::int32 numberofplayers() const;
  void set_numberofplayers(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_numberofplayers() const;
  void _internal_set_numberofplayers(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:game.NumberOfPlayers)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 numberofplayers_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class GameId :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.GameId) */ {
 public:
  GameId();
  virtual ~GameId();

  GameId(const GameId& from);
  GameId(GameId&& from) noexcept
    : GameId() {
    *this = ::std::move(from);
  }

  inline GameId& operator=(const GameId& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameId& operator=(GameId&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameId& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameId* internal_default_instance() {
    return reinterpret_cast<const GameId*>(
               &_GameId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GameId& a, GameId& b) {
    a.Swap(&b);
  }
  inline void Swap(GameId* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameId* New() const final {
    return CreateMaybeMessage<GameId>(nullptr);
  }

  GameId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameId>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameId& from);
  void MergeFrom(const GameId& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameId* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.GameId";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_game_2eproto);
    return ::descriptor_table_game_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
  };
  // int32 gameId = 1;
  void clear_gameid();
  ::PROTOBUF_NAMESPACE_ID::int32 gameid() const;
  void set_gameid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_gameid() const;
  void _internal_set_gameid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:game.GameId)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 gameid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class OrderInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.OrderInfo) */ {
 public:
  OrderInfo();
  virtual ~OrderInfo();

  OrderInfo(const OrderInfo& from);
  OrderInfo(OrderInfo&& from) noexcept
    : OrderInfo() {
    *this = ::std::move(from);
  }

  inline OrderInfo& operator=(const OrderInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderInfo& operator=(OrderInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OrderInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OrderInfo* internal_default_instance() {
    return reinterpret_cast<const OrderInfo*>(
               &_OrderInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(OrderInfo& a, OrderInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OrderInfo* New() const final {
    return CreateMaybeMessage<OrderInfo>(nullptr);
  }

  OrderInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OrderInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OrderInfo& from);
  void MergeFrom(const OrderInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.OrderInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_game_2eproto);
    return ::descriptor_table_game_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNumberOfPlayersFieldNumber = 2,
    kGameIdFieldNumber = 3,
    kSeedFieldNumber = 4,
  };
  // int32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 numberOfPlayers = 2;
  void clear_numberofplayers();
  ::PROTOBUF_NAMESPACE_ID::int32 numberofplayers() const;
  void set_numberofplayers(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_numberofplayers() const;
  void _internal_set_numberofplayers(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 gameId = 3;
  void clear_gameid();
  ::PROTOBUF_NAMESPACE_ID::int32 gameid() const;
  void set_gameid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_gameid() const;
  void _internal_set_gameid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // uint32 seed = 4;
  void clear_seed();
  ::PROTOBUF_NAMESPACE_ID::uint32 seed() const;
  void set_seed(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_seed() const;
  void _internal_set_seed(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:game.OrderInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  ::PROTOBUF_NAMESPACE_ID::int32 numberofplayers_;
  ::PROTOBUF_NAMESPACE_ID::int32 gameid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 seed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class Player :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.Player) */ {
 public:
  Player();
  virtual ~Player();

  Player(const Player& from);
  Player(Player&& from) noexcept
    : Player() {
    *this = ::std::move(from);
  }

  inline Player& operator=(const Player& from) {
    CopyFrom(from);
    return *this;
  }
  inline Player& operator=(Player&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Player& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Player* internal_default_instance() {
    return reinterpret_cast<const Player*>(
               &_Player_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Player& a, Player& b) {
    a.Swap(&b);
  }
  inline void Swap(Player* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Player* New() const final {
    return CreateMaybeMessage<Player>(nullptr);
  }

  Player* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Player>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Player& from);
  void MergeFrom(const Player& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Player* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.Player";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_game_2eproto);
    return ::descriptor_table_game_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kGameIdFieldNumber = 2,
  };
  // int32 playerId = 1;
  void clear_playerid();
  ::PROTOBUF_NAMESPACE_ID::int32 playerid() const;
  void set_playerid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_playerid() const;
  void _internal_set_playerid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 gameId = 2;
  void clear_gameid();
  ::PROTOBUF_NAMESPACE_ID::int32 gameid() const;
  void set_gameid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_gameid() const;
  void _internal_set_gameid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:game.Player)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 playerid_;
  ::PROTOBUF_NAMESPACE_ID::int32 gameid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class Event :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.Event) */ {
 public:
  Event();
  virtual ~Event();

  Event(const Event& from);
  Event(Event&& from) noexcept
    : Event() {
    *this = ::std::move(from);
  }

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  inline Event& operator=(Event&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Event& default_instance();

  enum EventInfoCase {
    kCardInfo = 4,
    kDiceInfo = 5,
    kMarketInfo = 6,
    kBuildInfo = 7,
    EVENTINFO_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
               &_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Event& a, Event& b) {
    a.Swap(&b);
  }
  inline void Swap(Event* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Event* New() const final {
    return CreateMaybeMessage<Event>(nullptr);
  }

  Event* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Event>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.Event";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_game_2eproto);
    return ::descriptor_table_game_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kPlayerIdFieldNumber = 2,
    kGameIdFieldNumber = 3,
    kCardInfoFieldNumber = 4,
    kDiceInfoFieldNumber = 5,
    kMarketInfoFieldNumber = 6,
    kBuildInfoFieldNumber = 7,
  };
  // .game.EventType type = 1;
  void clear_type();
  ::game::EventType type() const;
  void set_type(::game::EventType value);
  private:
  ::game::EventType _internal_type() const;
  void _internal_set_type(::game::EventType value);
  public:

  // int32 playerId = 2;
  void clear_playerid();
  ::PROTOBUF_NAMESPACE_ID::int32 playerid() const;
  void set_playerid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_playerid() const;
  void _internal_set_playerid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 gameId = 3;
  void clear_gameid();
  ::PROTOBUF_NAMESPACE_ID::int32 gameid() const;
  void set_gameid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_gameid() const;
  void _internal_set_gameid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .game.Card cardInfo = 4;
  bool has_cardinfo() const;
  private:
  bool _internal_has_cardinfo() const;
  public:
  void clear_cardinfo();
  const ::game::Card& cardinfo() const;
  ::game::Card* release_cardinfo();
  ::game::Card* mutable_cardinfo();
  void set_allocated_cardinfo(::game::Card* cardinfo);
  private:
  const ::game::Card& _internal_cardinfo() const;
  ::game::Card* _internal_mutable_cardinfo();
  public:

  // .game.Dice diceInfo = 5;
  bool has_diceinfo() const;
  private:
  bool _internal_has_diceinfo() const;
  public:
  void clear_diceinfo();
  const ::game::Dice& diceinfo() const;
  ::game::Dice* release_diceinfo();
  ::game::Dice* mutable_diceinfo();
  void set_allocated_diceinfo(::game::Dice* diceinfo);
  private:
  const ::game::Dice& _internal_diceinfo() const;
  ::game::Dice* _internal_mutable_diceinfo();
  public:

  // .game.Market marketInfo = 6;
  bool has_marketinfo() const;
  private:
  bool _internal_has_marketinfo() const;
  public:
  void clear_marketinfo();
  const ::game::Market& marketinfo() const;
  ::game::Market* release_marketinfo();
  ::game::Market* mutable_marketinfo();
  void set_allocated_marketinfo(::game::Market* marketinfo);
  private:
  const ::game::Market& _internal_marketinfo() const;
  ::game::Market* _internal_mutable_marketinfo();
  public:

  // .game.Build buildInfo = 7;
  bool has_buildinfo() const;
  private:
  bool _internal_has_buildinfo() const;
  public:
  void clear_buildinfo();
  const ::game::Build& buildinfo() const;
  ::game::Build* release_buildinfo();
  ::game::Build* mutable_buildinfo();
  void set_allocated_buildinfo(::game::Build* buildinfo);
  private:
  const ::game::Build& _internal_buildinfo() const;
  ::game::Build* _internal_mutable_buildinfo();
  public:

  void clear_EventInfo();
  EventInfoCase EventInfo_case() const;
  // @@protoc_insertion_point(class_scope:game.Event)
 private:
  class _Internal;
  void set_has_cardinfo();
  void set_has_diceinfo();
  void set_has_marketinfo();
  void set_has_buildinfo();

  inline bool has_EventInfo() const;
  inline void clear_has_EventInfo();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  int type_;
  ::PROTOBUF_NAMESPACE_ID::int32 playerid_;
  ::PROTOBUF_NAMESPACE_ID::int32 gameid_;
  union EventInfoUnion {
    EventInfoUnion() {}
    ::game::Card* cardinfo_;
    ::game::Dice* diceinfo_;
    ::game::Market* marketinfo_;
    ::game::Build* buildinfo_;
  } EventInfo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class Card :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.Card) */ {
 public:
  Card();
  virtual ~Card();

  Card(const Card& from);
  Card(Card&& from) noexcept
    : Card() {
    *this = ::std::move(from);
  }

  inline Card& operator=(const Card& from) {
    CopyFrom(from);
    return *this;
  }
  inline Card& operator=(Card&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Card& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Card* internal_default_instance() {
    return reinterpret_cast<const Card*>(
               &_Card_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Card& a, Card& b) {
    a.Swap(&b);
  }
  inline void Swap(Card* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Card* New() const final {
    return CreateMaybeMessage<Card>(nullptr);
  }

  Card* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Card>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Card& from);
  void MergeFrom(const Card& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Card* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.Card";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_game_2eproto);
    return ::descriptor_table_game_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCardTypeFieldNumber = 1,
    kExtraDataFieldNumber = 2,
  };
  // int32 cardType = 1;
  void clear_cardtype();
  ::PROTOBUF_NAMESPACE_ID::int32 cardtype() const;
  void set_cardtype(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_cardtype() const;
  void _internal_set_cardtype(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 extraData = 2;
  void clear_extradata();
  ::PROTOBUF_NAMESPACE_ID::int32 extradata() const;
  void set_extradata(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_extradata() const;
  void _internal_set_extradata(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:game.Card)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 cardtype_;
  ::PROTOBUF_NAMESPACE_ID::int32 extradata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class Dice :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.Dice) */ {
 public:
  Dice();
  virtual ~Dice();

  Dice(const Dice& from);
  Dice(Dice&& from) noexcept
    : Dice() {
    *this = ::std::move(from);
  }

  inline Dice& operator=(const Dice& from) {
    CopyFrom(from);
    return *this;
  }
  inline Dice& operator=(Dice&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Dice& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Dice* internal_default_instance() {
    return reinterpret_cast<const Dice*>(
               &_Dice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Dice& a, Dice& b) {
    a.Swap(&b);
  }
  inline void Swap(Dice* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Dice* New() const final {
    return CreateMaybeMessage<Dice>(nullptr);
  }

  Dice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Dice>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Dice& from);
  void MergeFrom(const Dice& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Dice* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.Dice";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_game_2eproto);
    return ::descriptor_table_game_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumber1FieldNumber = 1,
    kNumber2FieldNumber = 2,
    kHexNumberFieldNumber = 3,
  };
  // int32 number1 = 1;
  void clear_number1();
  ::PROTOBUF_NAMESPACE_ID::int32 number1() const;
  void set_number1(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_number1() const;
  void _internal_set_number1(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 number2 = 2;
  void clear_number2();
  ::PROTOBUF_NAMESPACE_ID::int32 number2() const;
  void set_number2(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_number2() const;
  void _internal_set_number2(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 hexNumber = 3;
  void clear_hexnumber();
  ::PROTOBUF_NAMESPACE_ID::int32 hexnumber() const;
  void set_hexnumber(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_hexnumber() const;
  void _internal_set_hexnumber(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:game.Dice)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 number1_;
  ::PROTOBUF_NAMESPACE_ID::int32 number2_;
  ::PROTOBUF_NAMESPACE_ID::int32 hexnumber_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class Market :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.Market) */ {
 public:
  Market();
  virtual ~Market();

  Market(const Market& from);
  Market(Market&& from) noexcept
    : Market() {
    *this = ::std::move(from);
  }

  inline Market& operator=(const Market& from) {
    CopyFrom(from);
    return *this;
  }
  inline Market& operator=(Market&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Market& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Market* internal_default_instance() {
    return reinterpret_cast<const Market*>(
               &_Market_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Market& a, Market& b) {
    a.Swap(&b);
  }
  inline void Swap(Market* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Market* New() const final {
    return CreateMaybeMessage<Market>(nullptr);
  }

  Market* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Market>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Market& from);
  void MergeFrom(const Market& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Market* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.Market";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_game_2eproto);
    return ::descriptor_table_game_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequiredResourceFieldNumber = 1,
    kOwnedResourceFieldNumber = 2,
  };
  // int32 requiredResource = 1;
  void clear_requiredresource();
  ::PROTOBUF_NAMESPACE_ID::int32 requiredresource() const;
  void set_requiredresource(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_requiredresource() const;
  void _internal_set_requiredresource(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 ownedResource = 2;
  void clear_ownedresource();
  ::PROTOBUF_NAMESPACE_ID::int32 ownedresource() const;
  void set_ownedresource(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_ownedresource() const;
  void _internal_set_ownedresource(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:game.Market)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 requiredresource_;
  ::PROTOBUF_NAMESPACE_ID::int32 ownedresource_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_game_2eproto;
};
// -------------------------------------------------------------------

class Build :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:game.Build) */ {
 public:
  Build();
  virtual ~Build();

  Build(const Build& from);
  Build(Build&& from) noexcept
    : Build() {
    *this = ::std::move(from);
  }

  inline Build& operator=(const Build& from) {
    CopyFrom(from);
    return *this;
  }
  inline Build& operator=(Build&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Build& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Build* internal_default_instance() {
    return reinterpret_cast<const Build*>(
               &_Build_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Build& a, Build& b) {
    a.Swap(&b);
  }
  inline void Swap(Build* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Build* New() const final {
    return CreateMaybeMessage<Build>(nullptr);
  }

  Build* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Build>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Build& from);
  void MergeFrom(const Build& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Build* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "game.Build";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_game_2eproto);
    return ::descriptor_table_game_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBuildingTypeFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
  };
  // int32 buildingType = 1;
  void clear_buildingtype();
  ::PROTOBUF_NAMESPACE_ID::int32 buildingtype() const;
  void set_buildingtype(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_buildingtype() const;
  void _internal_set_buildingtype(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 x = 2;
  void clear_x();
  ::PROTOBUF_NAMESPACE_ID::int32 x() const;
  void set_x(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_x() const;
  void _internal_set_x(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 y = 3;
  void clear_y();
  ::PROTOBUF_NAMESPACE_ID::int32 y() const;
  void set_y(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_y() const;
  void _internal_set_y(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:game.Build)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 buildingtype_;
  ::PROTOBUF_NAMESPACE_ID::int32 x_;
  ::PROTOBUF_NAMESPACE_ID::int32 y_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_game_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Void

// -------------------------------------------------------------------

// Bool

// bool hasEvent = 1;
inline void Bool::clear_hasevent() {
  hasevent_ = false;
}
inline bool Bool::_internal_hasevent() const {
  return hasevent_;
}
inline bool Bool::hasevent() const {
  // @@protoc_insertion_point(field_get:game.Bool.hasEvent)
  return _internal_hasevent();
}
inline void Bool::_internal_set_hasevent(bool value) {
  
  hasevent_ = value;
}
inline void Bool::set_hasevent(bool value) {
  _internal_set_hasevent(value);
  // @@protoc_insertion_point(field_set:game.Bool.hasEvent)
}

// -------------------------------------------------------------------

// NumberOfPlayers

// int32 numberOfPlayers = 1;
inline void NumberOfPlayers::clear_numberofplayers() {
  numberofplayers_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NumberOfPlayers::_internal_numberofplayers() const {
  return numberofplayers_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NumberOfPlayers::numberofplayers() const {
  // @@protoc_insertion_point(field_get:game.NumberOfPlayers.numberOfPlayers)
  return _internal_numberofplayers();
}
inline void NumberOfPlayers::_internal_set_numberofplayers(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  numberofplayers_ = value;
}
inline void NumberOfPlayers::set_numberofplayers(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_numberofplayers(value);
  // @@protoc_insertion_point(field_set:game.NumberOfPlayers.numberOfPlayers)
}

// -------------------------------------------------------------------

// GameId

// int32 gameId = 1;
inline void GameId::clear_gameid() {
  gameid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameId::_internal_gameid() const {
  return gameid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameId::gameid() const {
  // @@protoc_insertion_point(field_get:game.GameId.gameId)
  return _internal_gameid();
}
inline void GameId::_internal_set_gameid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  gameid_ = value;
}
inline void GameId::set_gameid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:game.GameId.gameId)
}

// -------------------------------------------------------------------

// OrderInfo

// int32 id = 1;
inline void OrderInfo::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OrderInfo::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OrderInfo::id() const {
  // @@protoc_insertion_point(field_get:game.OrderInfo.id)
  return _internal_id();
}
inline void OrderInfo::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
}
inline void OrderInfo::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:game.OrderInfo.id)
}

// int32 numberOfPlayers = 2;
inline void OrderInfo::clear_numberofplayers() {
  numberofplayers_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OrderInfo::_internal_numberofplayers() const {
  return numberofplayers_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OrderInfo::numberofplayers() const {
  // @@protoc_insertion_point(field_get:game.OrderInfo.numberOfPlayers)
  return _internal_numberofplayers();
}
inline void OrderInfo::_internal_set_numberofplayers(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  numberofplayers_ = value;
}
inline void OrderInfo::set_numberofplayers(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_numberofplayers(value);
  // @@protoc_insertion_point(field_set:game.OrderInfo.numberOfPlayers)
}

// int32 gameId = 3;
inline void OrderInfo::clear_gameid() {
  gameid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OrderInfo::_internal_gameid() const {
  return gameid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 OrderInfo::gameid() const {
  // @@protoc_insertion_point(field_get:game.OrderInfo.gameId)
  return _internal_gameid();
}
inline void OrderInfo::_internal_set_gameid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  gameid_ = value;
}
inline void OrderInfo::set_gameid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:game.OrderInfo.gameId)
}

// uint32 seed = 4;
inline void OrderInfo::clear_seed() {
  seed_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 OrderInfo::_internal_seed() const {
  return seed_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 OrderInfo::seed() const {
  // @@protoc_insertion_point(field_get:game.OrderInfo.seed)
  return _internal_seed();
}
inline void OrderInfo::_internal_set_seed(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  seed_ = value;
}
inline void OrderInfo::set_seed(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_seed(value);
  // @@protoc_insertion_point(field_set:game.OrderInfo.seed)
}

// -------------------------------------------------------------------

// Player

// int32 playerId = 1;
inline void Player::clear_playerid() {
  playerid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Player::_internal_playerid() const {
  return playerid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Player::playerid() const {
  // @@protoc_insertion_point(field_get:game.Player.playerId)
  return _internal_playerid();
}
inline void Player::_internal_set_playerid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  playerid_ = value;
}
inline void Player::set_playerid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:game.Player.playerId)
}

// int32 gameId = 2;
inline void Player::clear_gameid() {
  gameid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Player::_internal_gameid() const {
  return gameid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Player::gameid() const {
  // @@protoc_insertion_point(field_get:game.Player.gameId)
  return _internal_gameid();
}
inline void Player::_internal_set_gameid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  gameid_ = value;
}
inline void Player::set_gameid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:game.Player.gameId)
}

// -------------------------------------------------------------------

// Event

// .game.EventType type = 1;
inline void Event::clear_type() {
  type_ = 0;
}
inline ::game::EventType Event::_internal_type() const {
  return static_cast< ::game::EventType >(type_);
}
inline ::game::EventType Event::type() const {
  // @@protoc_insertion_point(field_get:game.Event.type)
  return _internal_type();
}
inline void Event::_internal_set_type(::game::EventType value) {
  
  type_ = value;
}
inline void Event::set_type(::game::EventType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:game.Event.type)
}

// int32 playerId = 2;
inline void Event::clear_playerid() {
  playerid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Event::_internal_playerid() const {
  return playerid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Event::playerid() const {
  // @@protoc_insertion_point(field_get:game.Event.playerId)
  return _internal_playerid();
}
inline void Event::_internal_set_playerid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  playerid_ = value;
}
inline void Event::set_playerid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_playerid(value);
  // @@protoc_insertion_point(field_set:game.Event.playerId)
}

// int32 gameId = 3;
inline void Event::clear_gameid() {
  gameid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Event::_internal_gameid() const {
  return gameid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Event::gameid() const {
  // @@protoc_insertion_point(field_get:game.Event.gameId)
  return _internal_gameid();
}
inline void Event::_internal_set_gameid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  gameid_ = value;
}
inline void Event::set_gameid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:game.Event.gameId)
}

// .game.Card cardInfo = 4;
inline bool Event::_internal_has_cardinfo() const {
  return EventInfo_case() == kCardInfo;
}
inline bool Event::has_cardinfo() const {
  return _internal_has_cardinfo();
}
inline void Event::set_has_cardinfo() {
  _oneof_case_[0] = kCardInfo;
}
inline void Event::clear_cardinfo() {
  if (_internal_has_cardinfo()) {
    delete EventInfo_.cardinfo_;
    clear_has_EventInfo();
  }
}
inline ::game::Card* Event::release_cardinfo() {
  // @@protoc_insertion_point(field_release:game.Event.cardInfo)
  if (_internal_has_cardinfo()) {
    clear_has_EventInfo();
      ::game::Card* temp = EventInfo_.cardinfo_;
    EventInfo_.cardinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::Card& Event::_internal_cardinfo() const {
  return _internal_has_cardinfo()
      ? *EventInfo_.cardinfo_
      : *reinterpret_cast< ::game::Card*>(&::game::_Card_default_instance_);
}
inline const ::game::Card& Event::cardinfo() const {
  // @@protoc_insertion_point(field_get:game.Event.cardInfo)
  return _internal_cardinfo();
}
inline ::game::Card* Event::_internal_mutable_cardinfo() {
  if (!_internal_has_cardinfo()) {
    clear_EventInfo();
    set_has_cardinfo();
    EventInfo_.cardinfo_ = CreateMaybeMessage< ::game::Card >(
        GetArenaNoVirtual());
  }
  return EventInfo_.cardinfo_;
}
inline ::game::Card* Event::mutable_cardinfo() {
  // @@protoc_insertion_point(field_mutable:game.Event.cardInfo)
  return _internal_mutable_cardinfo();
}

// .game.Dice diceInfo = 5;
inline bool Event::_internal_has_diceinfo() const {
  return EventInfo_case() == kDiceInfo;
}
inline bool Event::has_diceinfo() const {
  return _internal_has_diceinfo();
}
inline void Event::set_has_diceinfo() {
  _oneof_case_[0] = kDiceInfo;
}
inline void Event::clear_diceinfo() {
  if (_internal_has_diceinfo()) {
    delete EventInfo_.diceinfo_;
    clear_has_EventInfo();
  }
}
inline ::game::Dice* Event::release_diceinfo() {
  // @@protoc_insertion_point(field_release:game.Event.diceInfo)
  if (_internal_has_diceinfo()) {
    clear_has_EventInfo();
      ::game::Dice* temp = EventInfo_.diceinfo_;
    EventInfo_.diceinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::Dice& Event::_internal_diceinfo() const {
  return _internal_has_diceinfo()
      ? *EventInfo_.diceinfo_
      : *reinterpret_cast< ::game::Dice*>(&::game::_Dice_default_instance_);
}
inline const ::game::Dice& Event::diceinfo() const {
  // @@protoc_insertion_point(field_get:game.Event.diceInfo)
  return _internal_diceinfo();
}
inline ::game::Dice* Event::_internal_mutable_diceinfo() {
  if (!_internal_has_diceinfo()) {
    clear_EventInfo();
    set_has_diceinfo();
    EventInfo_.diceinfo_ = CreateMaybeMessage< ::game::Dice >(
        GetArenaNoVirtual());
  }
  return EventInfo_.diceinfo_;
}
inline ::game::Dice* Event::mutable_diceinfo() {
  // @@protoc_insertion_point(field_mutable:game.Event.diceInfo)
  return _internal_mutable_diceinfo();
}

// .game.Market marketInfo = 6;
inline bool Event::_internal_has_marketinfo() const {
  return EventInfo_case() == kMarketInfo;
}
inline bool Event::has_marketinfo() const {
  return _internal_has_marketinfo();
}
inline void Event::set_has_marketinfo() {
  _oneof_case_[0] = kMarketInfo;
}
inline void Event::clear_marketinfo() {
  if (_internal_has_marketinfo()) {
    delete EventInfo_.marketinfo_;
    clear_has_EventInfo();
  }
}
inline ::game::Market* Event::release_marketinfo() {
  // @@protoc_insertion_point(field_release:game.Event.marketInfo)
  if (_internal_has_marketinfo()) {
    clear_has_EventInfo();
      ::game::Market* temp = EventInfo_.marketinfo_;
    EventInfo_.marketinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::Market& Event::_internal_marketinfo() const {
  return _internal_has_marketinfo()
      ? *EventInfo_.marketinfo_
      : *reinterpret_cast< ::game::Market*>(&::game::_Market_default_instance_);
}
inline const ::game::Market& Event::marketinfo() const {
  // @@protoc_insertion_point(field_get:game.Event.marketInfo)
  return _internal_marketinfo();
}
inline ::game::Market* Event::_internal_mutable_marketinfo() {
  if (!_internal_has_marketinfo()) {
    clear_EventInfo();
    set_has_marketinfo();
    EventInfo_.marketinfo_ = CreateMaybeMessage< ::game::Market >(
        GetArenaNoVirtual());
  }
  return EventInfo_.marketinfo_;
}
inline ::game::Market* Event::mutable_marketinfo() {
  // @@protoc_insertion_point(field_mutable:game.Event.marketInfo)
  return _internal_mutable_marketinfo();
}

// .game.Build buildInfo = 7;
inline bool Event::_internal_has_buildinfo() const {
  return EventInfo_case() == kBuildInfo;
}
inline bool Event::has_buildinfo() const {
  return _internal_has_buildinfo();
}
inline void Event::set_has_buildinfo() {
  _oneof_case_[0] = kBuildInfo;
}
inline void Event::clear_buildinfo() {
  if (_internal_has_buildinfo()) {
    delete EventInfo_.buildinfo_;
    clear_has_EventInfo();
  }
}
inline ::game::Build* Event::release_buildinfo() {
  // @@protoc_insertion_point(field_release:game.Event.buildInfo)
  if (_internal_has_buildinfo()) {
    clear_has_EventInfo();
      ::game::Build* temp = EventInfo_.buildinfo_;
    EventInfo_.buildinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::Build& Event::_internal_buildinfo() const {
  return _internal_has_buildinfo()
      ? *EventInfo_.buildinfo_
      : *reinterpret_cast< ::game::Build*>(&::game::_Build_default_instance_);
}
inline const ::game::Build& Event::buildinfo() const {
  // @@protoc_insertion_point(field_get:game.Event.buildInfo)
  return _internal_buildinfo();
}
inline ::game::Build* Event::_internal_mutable_buildinfo() {
  if (!_internal_has_buildinfo()) {
    clear_EventInfo();
    set_has_buildinfo();
    EventInfo_.buildinfo_ = CreateMaybeMessage< ::game::Build >(
        GetArenaNoVirtual());
  }
  return EventInfo_.buildinfo_;
}
inline ::game::Build* Event::mutable_buildinfo() {
  // @@protoc_insertion_point(field_mutable:game.Event.buildInfo)
  return _internal_mutable_buildinfo();
}

inline bool Event::has_EventInfo() const {
  return EventInfo_case() != EVENTINFO_NOT_SET;
}
inline void Event::clear_has_EventInfo() {
  _oneof_case_[0] = EVENTINFO_NOT_SET;
}
inline Event::EventInfoCase Event::EventInfo_case() const {
  return Event::EventInfoCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Card

// int32 cardType = 1;
inline void Card::clear_cardtype() {
  cardtype_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Card::_internal_cardtype() const {
  return cardtype_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Card::cardtype() const {
  // @@protoc_insertion_point(field_get:game.Card.cardType)
  return _internal_cardtype();
}
inline void Card::_internal_set_cardtype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  cardtype_ = value;
}
inline void Card::set_cardtype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_cardtype(value);
  // @@protoc_insertion_point(field_set:game.Card.cardType)
}

// int32 extraData = 2;
inline void Card::clear_extradata() {
  extradata_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Card::_internal_extradata() const {
  return extradata_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Card::extradata() const {
  // @@protoc_insertion_point(field_get:game.Card.extraData)
  return _internal_extradata();
}
inline void Card::_internal_set_extradata(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  extradata_ = value;
}
inline void Card::set_extradata(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_extradata(value);
  // @@protoc_insertion_point(field_set:game.Card.extraData)
}

// -------------------------------------------------------------------

// Dice

// int32 number1 = 1;
inline void Dice::clear_number1() {
  number1_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Dice::_internal_number1() const {
  return number1_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Dice::number1() const {
  // @@protoc_insertion_point(field_get:game.Dice.number1)
  return _internal_number1();
}
inline void Dice::_internal_set_number1(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  number1_ = value;
}
inline void Dice::set_number1(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_number1(value);
  // @@protoc_insertion_point(field_set:game.Dice.number1)
}

// int32 number2 = 2;
inline void Dice::clear_number2() {
  number2_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Dice::_internal_number2() const {
  return number2_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Dice::number2() const {
  // @@protoc_insertion_point(field_get:game.Dice.number2)
  return _internal_number2();
}
inline void Dice::_internal_set_number2(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  number2_ = value;
}
inline void Dice::set_number2(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_number2(value);
  // @@protoc_insertion_point(field_set:game.Dice.number2)
}

// int32 hexNumber = 3;
inline void Dice::clear_hexnumber() {
  hexnumber_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Dice::_internal_hexnumber() const {
  return hexnumber_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Dice::hexnumber() const {
  // @@protoc_insertion_point(field_get:game.Dice.hexNumber)
  return _internal_hexnumber();
}
inline void Dice::_internal_set_hexnumber(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  hexnumber_ = value;
}
inline void Dice::set_hexnumber(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_hexnumber(value);
  // @@protoc_insertion_point(field_set:game.Dice.hexNumber)
}

// -------------------------------------------------------------------

// Market

// int32 requiredResource = 1;
inline void Market::clear_requiredresource() {
  requiredresource_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Market::_internal_requiredresource() const {
  return requiredresource_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Market::requiredresource() const {
  // @@protoc_insertion_point(field_get:game.Market.requiredResource)
  return _internal_requiredresource();
}
inline void Market::_internal_set_requiredresource(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  requiredresource_ = value;
}
inline void Market::set_requiredresource(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_requiredresource(value);
  // @@protoc_insertion_point(field_set:game.Market.requiredResource)
}

// int32 ownedResource = 2;
inline void Market::clear_ownedresource() {
  ownedresource_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Market::_internal_ownedresource() const {
  return ownedresource_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Market::ownedresource() const {
  // @@protoc_insertion_point(field_get:game.Market.ownedResource)
  return _internal_ownedresource();
}
inline void Market::_internal_set_ownedresource(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  ownedresource_ = value;
}
inline void Market::set_ownedresource(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_ownedresource(value);
  // @@protoc_insertion_point(field_set:game.Market.ownedResource)
}

// -------------------------------------------------------------------

// Build

// int32 buildingType = 1;
inline void Build::clear_buildingtype() {
  buildingtype_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Build::_internal_buildingtype() const {
  return buildingtype_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Build::buildingtype() const {
  // @@protoc_insertion_point(field_get:game.Build.buildingType)
  return _internal_buildingtype();
}
inline void Build::_internal_set_buildingtype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  buildingtype_ = value;
}
inline void Build::set_buildingtype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_buildingtype(value);
  // @@protoc_insertion_point(field_set:game.Build.buildingType)
}

// int32 x = 2;
inline void Build::clear_x() {
  x_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Build::_internal_x() const {
  return x_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Build::x() const {
  // @@protoc_insertion_point(field_get:game.Build.x)
  return _internal_x();
}
inline void Build::_internal_set_x(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  x_ = value;
}
inline void Build::set_x(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:game.Build.x)
}

// int32 y = 3;
inline void Build::clear_y() {
  y_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Build::_internal_y() const {
  return y_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Build::y() const {
  // @@protoc_insertion_point(field_get:game.Build.y)
  return _internal_y();
}
inline void Build::_internal_set_y(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  y_ = value;
}
inline void Build::set_y(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:game.Build.y)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace game

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::game::EventType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::game::EventType>() {
  return ::game::EventType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_game_2eproto
